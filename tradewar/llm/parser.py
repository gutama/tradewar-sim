"""Response parsing utilities for LLM outputs in the trade war simulation."""

import logging
import re
from typing import Dict, List, Optional, Tuple, Union

from tradewar.economics.models import ActionType, Country, EconomicAction
from tradewar.simulation.state import SimulationState

logger = logging.getLogger(__name__)


class LLMResponseParser:
    """
    Parser for extracting structured data from LLM responses.
    
    This class provides utilities to extract economic actions, policy decisions,
    and other structured information from text responses generated by LLMs.
    """
    
    def parse_action_response(
        self,
        response: str,
        country: Country,
        state: SimulationState,
    ) -> Optional[EconomicAction]:
        """Compatibility wrapper for parsing policy action responses."""
        return self.parse_policy_action(response, country, state)

    def parse_policy_action(
        self, 
        response: str,
        country: Country,
        state: SimulationState
    ) -> Optional[EconomicAction]:
        """
        Parse an economic action from a policy decision response.
        
        Args:
            response: Raw text response from the LLM
            country: The country taking the action
            state: Current simulation state
            
        Returns:
            Parsed EconomicAction or None if parsing failed
        """
        try:
            # Extract the key components using regex patterns
            action_type = self._extract_field(response, r"ACTION:\s*(\w+)")
            target_country_name = self._extract_field(response, r"TARGET_COUNTRY:\s*(\w+)")
            sectors_text = self._extract_field(response, r"SECTORS:\s*(.+)")
            magnitude_text = self._extract_field(response, r"MAGNITUDE:\s*(\d+(?:\.\d+)?)")
            justification = self._extract_field(response, r"JUSTIFICATION:\s*(.+)")
            
            # Handle missing fields
            if not action_type or not magnitude_text:
                logger.warning(f"Missing required fields in LLM response for {country.name}")
                return None
            
            # Process target country
            target_country = None
            if target_country_name and target_country_name.lower() not in ["none", "n/a"]:
                # Find matching country in simulation
                for sim_country in state.countries:
                    if sim_country.name.lower() == target_country_name.lower():
                        target_country = sim_country
                        break
            
            # Process sectors list
            sectors = []
            if sectors_text:
                # Split by commas and clean up whitespace
                sectors = [s.strip() for s in sectors_text.split(",")]
            
            # Process magnitude (convert percentage to decimal)
            try:
                magnitude = float(magnitude_text)
                # If it's a percentage (e.g., 25 instead of 0.25), convert it
                if magnitude > 1.0:
                    magnitude = magnitude / 100.0
            except ValueError:
                logger.warning(f"Invalid magnitude value in LLM response: {magnitude_text}")
                magnitude = 0.1  # Default to 10% as fallback
            
            try:
                parsed_action_type = ActionType(action_type.lower())
            except ValueError:
                logger.warning(f"Unsupported action type from LLM: {action_type}")
                return None

            # Create the economic action
            return EconomicAction(
                country=country,
                action_type=parsed_action_type,
                target_country=target_country,
                sectors=sectors,
                magnitude=magnitude,
                justification=justification or "LLM-generated policy decision"
            )
        
        except Exception as e:
            logger.error(f"Error parsing LLM response: {str(e)}")
            logger.debug(f"Raw response: {response}")
            return None
    
    def parse_impact_assessment(self, response: str) -> Dict[str, float]:
        """Extract economic impact assessments from the LLM response."""
        impacts = {}
        
        # Look for common indicators
        for indicator in ["gdp", "inflation", "unemployment", "trade"]:
            match = re.search(fr"{indicator}:?\s*([-+]?\d+\.?\d*)%", response, re.IGNORECASE)
            if match:
                # Convert percentage to decimal (divide by 100) with exact precision
                value_str = match.group(1)
                value_float = float(value_str) / 100.0
                # Round to ensure exact precision to match expected test values
                impacts[indicator] = round(value_float, 5)
        
        return impacts
    
    def parse_stability_assessment(
        self,
        response: str
    ) -> Tuple[float, str]:
        """
        Parse economic stability assessment from LLM response.
        
        Args:
            response: Raw text response from the LLM
            
        Returns:
            Tuple of (stability score from 0-1, reasoning)
        """
        # Extract stability score
        score_match = re.search(r"STABILITY_SCORE[:\s]*(\d+(?:\.\d+)?)", response)
        score = 0.5  # Default to neutral
        
        if score_match:
            try:
                score = float(score_match.group(1))
                # If score is 0-100 scale, normalize to 0-1
                if score > 1.0:
                    score = score / 100.0
            except ValueError:
                logger.warning(f"Invalid stability score in response: {score_match.group(1)}")
        
        # Extract reasoning
        reasoning_match = re.search(r"REASONING[:\s]*([\s\S]+?)(?=\n\n|\Z)", response)
        reasoning = reasoning_match.group(1).strip() if reasoning_match else "No reasoning provided."
        
        return score, reasoning
    
    def _extract_field(self, text: str, pattern: str) -> Optional[str]:
        """Extract a field using regex and clean up the result."""
        match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
        if match:
            # Extract the first capture group and clean up whitespace
            return match.group(1).strip()
        return None
    
    def _convert_percentage(self, value_str: str) -> float:
        """Convert a percentage string to a decimal value."""
        try:
            value = float(value_str)
            # If it's already small (likely already decimal), return as is
            if -1.0 < value < 1.0:
                return value
            # Otherwise convert from percentage
            return value / 100.0
        except ValueError:
            logger.warning(f"Could not convert value to float: {value_str}")
            return 0.0
